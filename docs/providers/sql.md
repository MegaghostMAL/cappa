**1 работа метода debug**
 - чтобы пользователь мог проверить работку своего кода без отсылки его на тестирование
для начала в качестве б.д., на которой проверяется код бирется либо первая тестовая б.д., либо пользователь
может уточнить в поле ввода свою собственную
if ".db" in input:
   stdin=input
else:
   stdin="bd_1.db"
 - затем создается копия выбранной из папки tests_bd б.д., и сохраняется
 в папку users_bd с названием равным ключу сессии пользователя
    create_db(stdin,kwargs['session_key']+".db")
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    db_path = os.path.join(BASE_DIR, "users_db\\"+kwargs['session_key']+".db")
 - после чего с помощью sqlite3 происходит подключение к б.д. db_path и на ней
 происходит выполнения кода пользователя content
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute(content)
 - затем в переменную output сохраняется вывод программы, на случай если он есть (при select запросах)
 и закрывается б.д.
    for res in c.fetchall():
    output += str(res)+"\n"
    c.close()
 - в конце, б.д. пользователя удаляется
    try:
        os.remove(os.path.join(BASE_DIR, "users_db\\" + kwargs['session_key'] + ".db"))
    except:
        pass
**2 работа метода check_tests**
 - Для начала получаем название метода сравнения результатов
    compare_method_name = f'_compare_{task.output_type}'
    compare_method = getattr(cls, compare_method_name)
 - Затем в цикле выполняются те-же действия, что и в методе debug,
 за исключением того, что каждый тест выполняется для тестовой б.д. под номером теста (тест 1 = bd_1.db, тест 2 = bd_2.db)
 и того, что после исполнения кода пользователя нужно различать 2 ситуации:
    1. В случае, если запрос не должен изменять данные (select-запрос), он обрабатывается как и в методе debug
    2. В случае изменения б.д. было решено во входных данных теста test['input'] посылать select-запрос,
    который применяется к б.д. пользователя и выводит данные таблиц, которые должны были быть изменены,
    после чего этот результат сравнивается с эталонным для теста test["output"]
  Для разлечения этих ситуаций был создан дополнительный тип данных sqlselect, и метод для сравнения этих данных
  _compare_sqlselect, которые работают как метка того, что  во входных данных теста находится select-запрос,
  что значит, что в этом задании происходит изменение б.д.
            if "sqlselect" not in compare_method_name:        #не изм. б.д. запрос
                    for res in c.fetchall():
                        output += str(res)+"\n"
                    success = compare_method(
                        etalon=clear_text(test['output']),
                        val=clear_text(output)
                    )
                    c.close()
                else:                                              #изм. б.д. запрос
                    c.execute(test['input'])                     #исполнение select-запроса из входных данных теста
                    for res in c.fetchall():
                        output += str(res)+"\n"
                    c.close()
                    success = compare_method(
                        etalon=test["output"],
                        val=output
                    )
**3 Замечания**
 - использовать для каждого теста свою б.д. приходится т.к. проверить правильность выолнения задания
 одним тестом не всегда возможно
 - использовать уже готовые неколько б.д. на сайте вместо подгрузки каждому тесту своей б.д. было
 решено т.к. это это было бы слишком громоздко для сайта
 - т.к. каждому тесту ставится тестовая б.д. с индексом номера теста (тест 1 = bd_1.db, тест 2 = bd_2.db)
 максимальное количество тестов ограничивается максимальным количеством б.д. на сервере
 - т.к. тестовые файлы б.д. используются для разных заданий, каждая из них должн включать в себя
 все возможные таблицы, заполненые разными данными